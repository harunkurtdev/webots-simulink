{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Webots-Simulink Bridge Documentation","text":"<p>Welcome to the documentation for the Webots-Simulink Bridge, a framework that enables communication between the Webots robotic simulator and Simulink. This bridge allows users to simulate and control robotic systems using Simulink while visualizing their behavior in Webots.</p>"},{"location":"#inverted-pendulum","title":"Inverted Pendulum","text":""},{"location":"#rotary-inverted-pendulum-system","title":"Rotary Inverted Pendulum System","text":""},{"location":"#crazyflie","title":"Crazyflie","text":""},{"location":"#blutboat","title":"BlutBoat","text":""},{"location":"#wheel-chair","title":"Wheel Chair","text":""},{"location":"#overview","title":"Overview","text":"<p>This project enables real-time interaction between Simulink and Webots allowing: - Simulation of robotic systems using Webots' physics engine. - Control algorithms to be implemented in Simulink. - Direct function calls from MATLAB to Webots for data exchange.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83e\udd16 Support for Various Robotic Platforms in Webots.  </li> <li>\ud83d\udee0\ufe0f Customizable Bridge Implementation for Different Use Cases.  </li> <li>\ud83d\udd04 Real-Time Bidirectional Data Exchange Between Webots and Simulink.  </li> <li>\ud83d\ude80 Seamless Integration of Simulink with ROS 2 for Robotic Applications.  </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, check out the Installation Guide to set up your environment and begin using the bridge.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Installation: Steps to install and configure the bridge.</li> <li>Usage: How to connect Webots and Simulink and run simulations, create a ros2 pkg.</li> <li>Advanced Topics: Customization, debugging, and performance tuning.</li> <li>Troubleshooting: Common issues and solutions.</li> <li>FAQs &amp; References: Additional information and external resources.</li> </ul> <p>Let's get started! \ud83d\ude80</p>"},{"location":"admonitions/","title":"Admonitions","text":"<p>Example of an admonition/callout with a title:</p> <p>Title of the callout</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Collapsible callout:</p> Collapsible callout <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"code-examples/","title":"Code examples","text":"<p>An example of a codeblock for Python:</p> add_numbers.py<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre> <p>Example codeblock for JavaScript with lines highlighted:</p> concatenate_strings.js<pre><code>// Function to concatenate two strings\nfunction concatenateStrings(str1, str2) {\n  return str1 + str2;\n}\n\n// Example usage\nconst result = concatenateStrings(\"Hello, \", \"World!\");\nconsole.log(\"The concatenated string is:\", result);\n</code></pre>"},{"location":"content-tabs/","title":"Content tabs","text":""},{"location":"content-tabs/#content-tabs","title":"Content Tabs","text":"<p>This is some examples of content tabs.</p>"},{"location":"content-tabs/#generic-content","title":"Generic Content","text":"Plain textUnordered listOrdered list <p>This is some plain text</p> <ul> <li>First item</li> <li>Second item</li> <li>Third item</li> </ul> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol>"},{"location":"content-tabs/#code-blocks-in-content-tabs","title":"Code Blocks in Content Tabs","text":"PythonJavaScript <pre><code>def main():\n    print(\"Hello world!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>function main() {\n    console.log(\"Hello world!\");\n}\n\nmain();\n</code></pre>"},{"location":"contributors/","title":"Contributors","text":""},{"location":"contributors/#contribute","title":"\ud83d\udca1 Contribute","text":""},{"location":"diagram-examples/","title":"Diagram Examples","text":""},{"location":"diagram-examples/#flowcharts","title":"Flowcharts","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Failure?};\n  B --&gt;|Yes| C[Investigate...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Success!];</code></pre>"},{"location":"diagram-examples/#sequence-diagrams","title":"Sequence Diagrams","text":"<pre><code>sequenceDiagram\n  autonumber\n  Server-&gt;&gt;Terminal: Send request\n  loop Health\n      Terminal-&gt;&gt;Terminal: Check for health\n  end\n  Note right of Terminal: System online\n  Terminal--&gt;&gt;Server: Everything is OK\n  Terminal-&gt;&gt;Database: Request customer data\n  Database--&gt;&gt;Terminal: Customer data</code></pre>"},{"location":"advanced/debugging/","title":"Debugging","text":""},{"location":"advanced/debugging/#how-to-debug-the-control-architecture-simulink-block","title":"How to Debug the Control Architecture Simulink Block","text":""},{"location":"advanced/debugging/#1-understand-the-problem","title":"1. Understand the Problem","text":"<ul> <li>Start by clearly defining what \"debugging\" means in the context of the Simulink block</li> <li>Reproduce the issue you're trying to debug</li> <li>Use scopes and displays within Simulink to visualize signals</li> </ul>"},{"location":"advanced/debugging/#2-use-debugging-tools","title":"2. Use Debugging Tools","text":"<ul> <li>Add breakpoints to your Simulink model</li> <li>Step through the simulation using the Step-by-Step solver</li> <li>Examine workspace variables at different time steps</li> <li>Use the Display block to output signal values</li> </ul>"},{"location":"advanced/debugging/#3-log-and-monitor-signals","title":"3. Log and Monitor Signals","text":"<ul> <li>Create subsystems to isolate different parts of your control architecture</li> <li>Add To Workspace blocks to capture signals for post-simulation analysis</li> <li>Plot signals using scopes or MATLAB figures</li> </ul>"},{"location":"advanced/debugging/#4-check-model-configuration","title":"4. Check Model Configuration","text":"<ul> <li>Verify solver settings (absolute/relative tolerance, step size)</li> <li>Ensure proper data types and sample times are set</li> <li>Check for algebraic loops and potential zero-crossing issues</li> </ul>"},{"location":"advanced/debugging/#5-when-stuck","title":"5. When Stuck","text":"<ul> <li>Clear the workspace and start fresh</li> <li>Run a smaller, simplified version of your model</li> <li>Seek help from colleagues or online forums</li> </ul> <p>By following these steps, you can systematically identify and resolve issues within your Simulink control architecture blocks.</p>"},{"location":"advanced/export-ros2/","title":"Export ROS2 Package","text":"<p>## Exporting Robot Model in ROS 2 Format</p> <p>In this section, we will learn how to export the robot model in ROS 2 format, we need to use the <code>export_ros2</code> function. This function takes two arguments: the name of the robot and the path where you want to save the exported file. The exported file will be a URDF (Unified Robot Description Format) file that can be used by other programs such as Gazebo or ROS 2.</p>"},{"location":"advanced/export-ros2/#webots-simulation-blocks","title":"Webots Simulation Blocks","text":"<p>We can use the Control Block to control the robot's movement.</p> <p></p>"},{"location":"advanced/export-ros2/#create-ros2-simulink-app","title":"Create ROS2 Simulink App","text":"<p>We getting from Webots simulation control block.</p>"},{"location":"advanced/export-ros2/#sensor-from-imu-sensor","title":"Sensor From IMU Sensor","text":"<p>We getting from with imu sensor.</p> <p></p>"},{"location":"advanced/export-ros2/#basicly-getting-command","title":"Basicly getting Command","text":""},{"location":"advanced/export-ros2/#send-actuator-to-robot","title":"Send Actuator to Robot","text":""},{"location":"advanced/export-ros2/#ros2-package-showing-like-this","title":"ROS2 Package showing like this","text":""},{"location":"advanced/export-ros2/#reference","title":"Reference","text":"<ul> <li>Webots Documentation</li> <li>Simulink Documentation</li> <li>ROS 2 Documentation</li> <li>Matlab ROS2 Documentation</li> </ul>"},{"location":"examples/blueboat-usv/","title":"BlueBoat USV","text":"<p>BlueBoat is a small unmanned surface vehicle developed by Blue Robotics. It is designed to be used for various applications such as navigation and control experiments.</p>"},{"location":"examples/blueboat-usv/#system-modeling","title":"System Modeling","text":"<p>The system consists of the following components:  * Propeller: The propeller drives the motors that power the thrusters.  * Thrusters: The thrusters generate thrust in all directions, allowing the vehicle to move forward or backward.  * Motors: The motors provide power to the thrusters and control their speed.  * Thruster Control System: This system controls the thrusters based on the desired motion of the vehicle.</p>"},{"location":"examples/crazyflie-drone/","title":"Crazyflie Drone Example","text":""},{"location":"examples/crazyflie-drone/#crazyflie-drone","title":"Crazyflie Drone","text":""},{"location":"examples/crazyflie-drone/#simulink-architecture","title":"Simulink Architecture","text":"<p>We can simulate a Crazyflie drone in Webots by following with Simulink Based Simulation.</p> <p>We must sensor define in matlab code with webots.</p> <p>The Crazyflie is a small quadcopter developed by Bitcraze that can be used for various applications such as navigation and control experiments.</p>"},{"location":"examples/crazyflie-drone/#specifications","title":"Specifications","text":"<ul> <li>Weight: 35g</li> <li>Dimensions: 9 x 9 x 4.5 cm</li> <li>Motors: 4 x Coreless DC motors</li> <li>Propellers: 3-inch propellers</li> </ul>"},{"location":"examples/crazyflie-drone/#features","title":"Features","text":"<ul> <li>Autonomous flight capabilities</li> <li>Compatible with various sensors (lidar, GPS, etc.)</li> <li>Can be programmed using Python or C++</li> </ul>"},{"location":"examples/crazyflie-drone/#usage-guide","title":"Usage Guide","text":"<p>To use the Crazyflie in your project, you can follow these steps:</p> <ol> <li>Install the Crazyflie SDK and connect it to your computer.</li> <li>Write a program that uses the Crazyflie's API to control its movements and sensors.</li> <li>Run the program on your computer or a Raspberry Pi.</li> <li>Use the Crazyflie in your project.</li> <li>Use the Crazyflie's API to collect data for further analysis.</li> <li>Use the Crazyflie's API to visualize data in real-time.</li> <li>Use the Crazyflie's API to control its movements and sensors.</li> </ol>"},{"location":"examples/inverted-pendulum/","title":"Inverted Pendulum","text":"<p>The inverted pendulum is a classic example in control system literature due to its inherent instability when open loop. In this system, a pendulum is mounted on a motorized cart. The control objective is to balance the pendulum by applying a force to the cart.</p> <p></p>"},{"location":"examples/inverted-pendulum/#1-problem-setup-and-design-requirements","title":"1. Problem Setup and Design Requirements","text":"<ul> <li>System Description:   A pendulum is mounted on a cart that can move horizontally. The system is unstable without control (the pendulum falls if not actively balanced). Inputs and Outputs:</li> <li>Input: Force ( F ) applied to the cart.</li> <li> <p>Outputs: Pendulum angle ( \\theta ) and cart position ( x ).</p> </li> <li> <p>Given Parameters:</p> </li> <li>( M ): Mass of the cart (0.5 kg)</li> <li>( m ): Mass of the pendulum (0.2 kg)</li> <li>( b ): Friction coefficient for the cart (0.1 N/m/s)</li> <li>( l ): Length to the pendulum's center of mass (0.3 m)</li> <li> <p>( I ): Moment of inertia of the pendulum (0.006 kg\u00b7m\u00b2)</p> </li> <li> <p>Design Criteria:</p> </li> <li>For single-input, single-output (SISO) control (pendulum angle control):<ul> <li>Settling time for ( \\theta ) less than 5 seconds.</li> <li>After an impulse of 1 N\u00b7s, the pendulum deviates no more than 0.05 radians from vertical.</li> </ul> </li> <li>For state-space design (SIMO) control:<ul> <li>A 0.2 m step in cart position: settling time under 5 seconds and rise time under 0.5 seconds.</li> <li>The pendulum angle deviation remains within 20\u00b0 (0.35 radians) of the vertical.</li> <li>Steady-state error less than 2% for both outputs.</li> </ul> </li> </ul>"},{"location":"examples/inverted-pendulum/#2-state-space","title":"2. State-Space","text":"<p>Note: It is recommended to use PID tuning to further refine the control performance of the inverted pendulum system.</p>"},{"location":"examples/inverted-pendulum/#reference","title":"Reference","text":"<ul> <li>Title: Inverted Pendulum: System Modeling  </li> <li>Source: University of Michigan Control Tutorials for MATLAB and Simulink (CTMS)  </li> <li>URL: https://ctms.engin.umich.edu/CTMS/index.php?example=InvertedPendulum&amp;section=SystemModeling</li> </ul> <p>Purpose: This reference serves as an educational resource for understanding the modeling of an inverted pendulum, a well-known unstable system. It explains how to derive the nonlinear equations of motion, linearize the system about its unstable equilibrium, and represent the system using both transfer functions and state-space models. Additionally, MATLAB code examples are provided for simulating the system and designing controllers, with PID tuning recommended as a means to improve control performance.</p>"},{"location":"examples/rotary-inverted-pendulum/","title":"Rotary Inverted Pendulum Example","text":""},{"location":"examples/rotary-inverted-pendulum/#system-modeling","title":"System Modeling","text":""},{"location":"examples/rotary-inverted-pendulum/#simulation-video","title":"Simulation Video","text":""},{"location":"examples/rotary-inverted-pendulum/#control-video","title":"Control Video","text":""},{"location":"examples/rotary-inverted-pendulum/#description-of-a-rotary-inverted-pendulum-system","title":"Description of a Rotary Inverted Pendulum System","text":"<p>A rotary inverted pendulum is a type of dynamic system that consists of a rotating bar with an inverted pendulum attached to its end. The system is often used as a benchmark for control systems and robotics research due to its non-linear and unstable dynamics.</p> <p>The rotary inverted pendulum has two degrees of freedom: the rotation of the bar around its vertical axis, and the swing of the pendulum around its pivot point. This results in a complex dynamic behavior that can be challenging to model and control.</p>"},{"location":"examples/rotary-inverted-pendulum/#components","title":"Components","text":"<ul> <li>Rotary Bar: The rotating part of the system, which supports the pendulum.</li> <li>Inverted Pendulum: The swinging part of the system, attached to the end of the rotary bar.</li> <li>Actuators: Motors or other devices responsible for controlling the rotation of the bar and the swing of the pendulum.</li> </ul>"},{"location":"examples/rotary-inverted-pendulum/#characteristics","title":"Characteristics","text":"<ul> <li>Non-linear dynamics</li> <li>Unstable equilibrium point</li> <li>Coupled degrees of freedom (rotation and swing)</li> <li>High sensitivity to initial conditions</li> </ul>"},{"location":"examples/rotary-inverted-pendulum/#mathematical-model","title":"Mathematical Model","text":"<p>The mathematical model of a rotary inverted pendulum system can be described using the following equations:</p> <ol> <li>Equilibrium Point: The system has an unstable equilibrium point, where both the rotation and swing are at their maximum values.</li> <li>Dynamics: The dynamics of the system can be modeled as a second-order differential equation, which describes how the system responds to changes in its state variables (rotation and swing).</li> </ol>"},{"location":"examples/rotary-inverted-pendulum/#control-strategy","title":"Control Strategy","text":"<p>To stabilize the rotary inverted pendulum system, we can use a control strategy that minimizes the error between the desired and actual states of the system. This can be achieved using feedback control techniques, such as proportional-integral-derivative (PID) control or other adaptive control methods.</p>"},{"location":"examples/rotary-inverted-pendulum/#implementation","title":"Implementation","text":"<p>The implementation of the rotary inverted pendulum system involves designing a controller that can stabilize its behavior based on the given mathematical model and control strategy. The controller should be able to adjust the input signals to the actuators in real-time, taking into account the current state of the system and adjusting the control parameters accordingly.</p>"},{"location":"examples/rotary-inverted-pendulum/#conclusion","title":"Conclusion","text":"<p>The rotary inverted pendulum system is a challenging problem that requires advanced control techniques and mathematical modeling to solve. By understanding the dynamics of the system and designing an appropriate controller, we can stabilize its behavior and achieve desired outcomes in real-world applications.</p>"},{"location":"examples/rotary-inverted-pendulum/#references","title":"References","text":"<ul> <li>Rotary Inverted Pendulum System</li> </ul>"},{"location":"examples/turtlebot3/","title":"Turtlebot3 Example","text":""},{"location":"examples/turtlebot3/#turtlebot3","title":"TurtleBot3","text":""},{"location":"examples/wheel-chair/","title":"WheelChair Example","text":""},{"location":"examples/wheel-chair/#introduction","title":"Introduction","text":"<p>In this tutorial how to we create simulation and simulation for a wheelchair. We will use the Webots simulator to create a virtual environment and simulate the behavior of a real-world wheelchair. We will start by creating a simple model of the wheelchair, including its components such as wheels, motors, and sensors. Then we will add control laws that allow us to move the wheelchair in different directions based on user input or other external factors. Finally, we will simulate the behavior of the wheelchair in a virtual environment and analyze its performance. </p> <p></p> <p></p>"},{"location":"examples/wheel-chair/#components","title":"Components","text":"<ul> <li>Wheels: The wheels that the wheelchair will move on.</li> <li>Motors: The motors that will drive the wheels and allow the wheelchair to move.</li> <li>Sensors: The sensors that will allow the wheelchair to inertial sensor data, such as accelerometers or gyroscopes.</li> <li>Actuators: The actuators that will allow the wheelchair to move, such as motors or wheels.</li> </ul> <p>We control the wheels by sending signals to the motors, which in turn move the wheels and allow the wheelchair to move. We can control the direction of movement by adjusting the speed of the motors or changing their position on the wheel. We can also adjust the speed and direction of movement by changing the position of the motors on the wheel. We can also use sensors to measure the position and orientation of the wheelchair, such as accelerometers or gyroscopes. These measurements allow us to adjust the speed and direction of movement based on the current state of the system.</p>"},{"location":"examples/wheel-chair/#control-system-design","title":"Control System Design","text":"<p>To design a control system for the wheelchair, we need to consider several factors: * The dynamics of the system: We need to model the non-linear and unstable behavior of the system.</p> <ul> <li> <p>The sensors and actuators available to us: We need to consider the types of sensors we have access to, such as accelerometers or gyroscopes, and the type of motors we can use.</p> </li> <li> <p>The desired behavior of the system: We need to define what we want the wheelchair to do, such as moving forward or turning left.</p> </li> <li> <p>The constraints on the system: We need to consider any physical or mechanical limitations that may affect the behavior of the system.</p> </li> </ul> <p>We can use a variety of control techniques, such as proportional-integral-derivative (PID) control, to design a control system for the wheelchair. PID control is a widely used technique in robotics and automation because it provides a balance between stability and responsiveness. PID control works by adjusting the speed and direction of movement based on the error between the desired position and the current position. This allows us to achieve a smooth and stable motion, even in the presence of non-linear dynamics and mechanical constraints. PID control is a powerful tool that can be used to achieve a wide range of desired behaviors for the wheelchair.</p>"},{"location":"examples/wheel-chair/#control-system-design-process","title":"Control System Design Process","text":"<p>The process for designing a control system for the wheelchair can be broken down into several steps: 1. Define the desired behavior of the wheelchair: This involves defining what we want the wheelchair to do, such as moving forward or turning left.</p> <ol> <li> <p>Identify the constraints on the system: This involves considering any physical or mechanical limitations that may affect the behavior of the wheelchair. We can use a variety of control techniques, such as proportional-integral-derivative (PID) control, to design a control system for the wheelchair. PID control is a widely used technique in robotics and automation because it provides a balance between stability and responsiveness. PID control works by adjusting the speed and direction of movement based on the error between the desired position and the current position. This allows us to achieve a smooth and stable motion, even in the presence of non-linear dynamics and mechanical constraints. PID control is a powerful tool that can be used to achieve a wide range of desired behaviors for the wheelchair.</p> </li> <li> <p>Evaluate the performance of the control system: Once we have designed a control system for the wheelchair, we need to evaluate its performance. This involves testing the system in real-world scenarios and measuring its response to different inputs. We can use various metrics to measure the performance of the control system, such as tracking error, velocity, and acceleration. We can also use simulation to test the performance of the control system under different conditions. Simulation allows us to predict how the control system will behave in real-world scenarios, and we can use this information to make improvements to the control system.</p> </li> <li> <p>Optimize the control system: Based on our evaluation of the performance of the control system, we can make improvements to the control system to improve its performance. This may involve adjusting the parameters of the PID controller or using other control techniques such as adaptive control or model predictive control.</p> </li> <li> <p>Test and validate the control system: Once we have optimized the control system, we need to test it in real-world scenarios to ensure that it is working correctly. We can use various methods to test the control system, such as manual testing, simulation, and field testing. Manual testing involves manually operating the wheelchair and measuring its response to different inputs. Simulation allows us to predict how the control system will behave in real-world scenarios, and we can use this information to make improvements to the control system. Field testing involves using the control system in a real-world scenario and measuring its performance.</p> </li> <li> <p>Deploy the control system: Once we have tested and validated the control system, we can deploy it in real-world scenarios to improve the performance of the wheelchair.</p> </li> <li> <p>Monitor and maintain the control system: After deployment, we need to monitor the performance of the control system and make any necessary adjustments as needed.</p> </li> <li> <p>Continuous improvement and innovation: Finally, we need to continuously improve and innovate the control system to keep up with the latest advancements in robotics and control systems. This may involve exploring new control techniques or incorporating new technologies such as machine learning or artificial intelligence.</p> </li> <li> <p>Conclusion: In conclusion, the wheel chair control system is a complex and challenging task that requires a deep understanding of robotics, control systems, and human-machine interaction. By following these steps, we can develop an effective control system for the wheelchair that improves its performance in real-world scenarios.</p> </li> </ol>"},{"location":"examples/wheel-chair/#wheelchair-control-examples","title":"Wheelchair Control Examples","text":"<p>Here you can find example implementations of different wheelchair control systems:</p> <ul> <li>Example 1: Basic manual control</li> <li>Example 2: Automatic navigation system</li> <li>Example 3: Joystick interface integration</li> </ul>"},{"location":"examples/wheel-chair/#references","title":"References","text":"<p>DrakerDG</p>"},{"location":"installation/requirements/","title":"Requirements","text":"<p>Before setting up the Webots-Simulink Bridge, ensure that your system meets the following requirements.</p>"},{"location":"installation/requirements/#software-requirements","title":"Software Requirements","text":"<ul> <li>MATLAB &amp; Simulink (Recommended: R2024a or later)</li> <li>Webots (Recommended: Latest stable version)</li> <li>C Compiler compatible with MATLAB (e.g., MinGW, MSVC)</li> </ul>"},{"location":"installation/requirements/#matlab-toolboxes","title":"MATLAB Toolboxes","text":"<p>Ensure that the following MATLAB toolboxes are installed: - MATLAB Coder (for interfacing with external libraries) - Simulink (for model-based design and simulation) - Embedded Coder (optional, for advanced code generation)</p>"},{"location":"installation/requirements/#system-requirements","title":"System Requirements","text":"<ul> <li>Operating System: Windows 10/11, Ubuntu 20.04+ (Recommended)</li> <li>RAM: At least 8GB (16GB recommended for large simulations)</li> <li>Processor: Multi-core processor (Intel i5/i7 or AMD Ryzen recommended)</li> <li>GPU: Dedicated GPU recommended for better rendering in Webots</li> </ul>"},{"location":"installation/requirements/#dependencies","title":"Dependencies","text":"<p>The following dependencies should be installed and configured properly: - Webots API (Ensure Webots' shared libraries are accessible by MATLAB) - MATLAB External Library Support (Proper setup of <code>calllib</code> for Webots' functions)</p> <p>Once these requirements are met, proceed to the Setup Guide to configure the bridge.</p>"},{"location":"installation/setup/","title":"Setup Guide","text":"<p>This guide will help you configure the Webots-Simulink Bridge to enable seamless interaction between Webots and MATLAB/Simulink.</p>"},{"location":"installation/setup/#1-install-webots","title":"1. Install Webots","text":"<ol> <li>Download Webots (recomendly 2023a) from the official website.</li> <li>Follow the installation instructions for your operating system.</li> <li>Verify the installation by running Webots and opening a sample world.</li> </ol>"},{"location":"installation/setup/#2-install-matlab-required-toolboxes","title":"2. Install MATLAB &amp; Required Toolboxes","text":"<ol> <li>Install MATLAB &amp; Simulink (R2024a or later recommended).</li> <li>Open MATLAB and ensure the following toolboxes are installed:</li> <li>MATLAB Coder</li> <li>Simulink</li> <li>Embedded Coder (optional)</li> <li>If a required toolbox is missing, install it using the MATLAB Add-On Manager.</li> </ol>"},{"location":"installation/setup/#3-configure-webots-library-in-matlab","title":"3. Configure Webots Library in MATLAB","text":"<p>Add Matlab Path</p> <p></p>"},{"location":"installation/setup/#next-steps","title":"Next Steps","text":"<p>After setup, refer to the Usage Guide to start running simulations with Webots and Simulink.</p>"},{"location":"usage/connecting/","title":"Connecting Webots and Simulink","text":""},{"location":"usage/connecting/#sensor-variables","title":"Sensor Variables","text":"<p>To establish a connection between the sensor and actuator variables with the robot, we need to define them first. We'll set the time step for the ODE4 method to 0.016 seconds as required. After defining these variables, we can use <code>open_system</code> and <code>open_load</code> functions to connect them properly. Specifically, the open_system function is used to establish communication between the robot and its sensor variable, whereas the actuator variable should be connected through the open_load function for seamless data transfer.</p>"},{"location":"usage/connecting/#dynamic-model","title":"Dynamic Model","text":"<p>To connect the dynamic model with the robot, we need to define a new system that combines both. We can create a new subsystem in Simulink by using the \"Subsystem\" block and adding the dynamic model as a child of this new subsystem. Then, we use the <code>open_system</code> function to connect the sensor variable to the input port of the new subsystem, and the actuator variable to the output port of the new subsystem.</p>"},{"location":"usage/connecting/#configuration","title":"Configuration","text":"<ol> <li>Fixed Step size: 0.016 seconds</li> <li>Solver Selection: Fixed step solver</li> <li>ODE method: ODE5</li> <li>Stop time: Infinite (using <code>Inf</code> instead of string)</li> <li>Simulation Start and Stop: Using <code>start</code> and <code>stop</code> functions</li> <li>Step Forward, Step by Step simulation: Using <code>step</code> function with incremental input</li> </ol>"},{"location":"usage/connecting/#workspace","title":"Workspace","text":"<p>Matlab Desktop Show a workspace with the robot, sensor variable, and actuator variable. You are able to see the variables in the workspace by clicking on them and use prompt commands.</p>"},{"location":"usage/connecting/#connect-robot","title":"Connect Robot","text":"<p>The robot is connected to automaticly by using open_system function. Simulink Blocks showing a Control Block, and Send Webots Simulation Blocks. The control block is used to send the robot's position and velocity to the webots simulation. The send webots simulation blocks are used to receive the robot's position and velocity from the webots simulation.</p>"},{"location":"usage/connecting/#connect-sensors","title":"Connect Sensors","text":"<p>if you want to webots simulator a sensor create a new variable in simulink workspace, then connect it with the sensor block. We talk about the sensors in the next section.   you can find about the this section.</p>"},{"location":"usage/customization/","title":"Customizing the Bridge","text":"<p>The bridge is a crucial component of Webots, responsible for connecting the simulation environment with your custom code. It allows you to interact with the simulation world and retrieve data from it. The bridge provides an interface between the simulation environment and your custom code.</p>"},{"location":"usage/customization/#this-will-be-changed","title":"This will be Changed","text":""},{"location":"usage/customization/#introduction","title":"Introduction","text":"<p>In Webots, the bridge plays a vital role in enabling communication between the simulation environment and your custom code. It acts as a conduit for data exchange, allowing you to interact with the simulation world and retrieve information from it. The bridge provides an interface between the simulation environment and your custom code.</p> <p></p> <p>First, we create and define our required variables in Matlab desktop. Then, we add our files to these variables for further usage. These files are taken from Webots GitHub repository and modified to be compatible with Simulink.</p> <p>The required variables include the robot model, simulation environment settings, and other necessary parameters. After defining these variables, we can use them to interact with the simulation world and retrieve data from it.</p> <p></p> <p>We now proceed to translate the functionality of our custom code into a series of function calls that will bridge the gap between our Matlab desktop environment and the Webots simulation engine.</p> <p></p> <p>In Figure 3, we call the sensor variables and constant variables that we defined in the Webots TextEditor as Constant by Simulink.</p> <p></p> <p>In Figure 4, the values \u200b\u200bof the fixed variables will be pulled from webots and these values \u200b\u200bare assigned.</p> <p>The functions defined in Figure 2 are called by Simulink. Thus, each step is processed by Webots every time the wb_robot_step function is called. It is ensured that it works in common with Simulink.</p>"},{"location":"usage/running/","title":"Running Simulations","text":""},{"location":"usage/running/#running-simulink-apps-in-webots","title":"Running Simulink Apps in Webots","text":"<p>Running the simulink apps is very simple. Just click on the \"Run\" button and you are done!</p> <p>if you want to stop the simulation, just click on the \"Stop\" button.</p> <p>and also you can see the output of your simulink app in the console.</p> <p>if you want to step forward the simulink apps, just click on the \"Step\" button.</p>"},{"location":"usage/running/#running-video","title":"Running Video","text":""}]}